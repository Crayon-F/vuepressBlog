## 1.为什么要使用vuex
 ### 1.单项数据流
 <img src='./images/flow.jpg' width='450px'>
 <br />
 <br />

 - state，驱动应用的数据源；
 - view，以声明方式将 state 映射到视图； 
- actions，响应在 view 上的用户输入导致的状态变化。(比如请求数据或者修改数据会导致数据源状态改变)  
### 2. 问题
 - 当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：
  1. 多个视图依赖于同一状态。
  2. 来自不同视图的行为需要变更同一状态。
- 解决  
  1. 对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。
  2. 对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。

- 思考

  我们为什么不把组件的共享状态抽取出来，以一个**全局单例模式**(惰性单例的设计模式)管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！

  通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。


## 2.什么是vuex
### 1.概念
  Vuex 是专门为 Vue.js 设计的状态管理库，它采用**集中式存储管理应用**的所有组件的状态。
### 2.什么是“状态管理模式”？
```js
new Vue({
  // state
  data () {
    return {
      count: 0
    }
  },
  // view
  template: `
    <div>{{ count }}</div>
  `,
  // actions
  methods: {
    increment () {
      this.count++
    }
  }
})
```
- 这是一个状态自管理应用,以这样理解，state，view，action，三部分都写在了组件内，状态由应用组件各自管理，即自己的状态自己管理。

- 而我们常说的状态管理，往往是指外部管理，目的是对状态和组件进行分离，
  具体到 Vuex 里的表现就是：把应用的所有组件的状态抽取出来，以一个全局单例模式在应用外部采用集中式存储管理。

- 状态管理其实就是把内部对 state 部分的操作，都拿到外部去了
### 3.为什么需要状态管理
<br />
<img src='./images/flow.jpg' width='450px'>
 <br />
 <br />

 - 1.view视图将state上的数据进行显示
 - 2.用户在view上进行操作，会触发actions去改变state中的数据
 - 3.state上的数据发生变化，通知视图进行更新

1. 在Vue或React中我们暂时不用关心1，3步骤，因为框架的核心就是实现双向数据绑定
2. 步骤2是我们参与的部分，也就是状态管理的部分

既然我们不暂时不用关心view层是如何进行双向绑定以及视图渲染，那我们为什么不把**状态管理**和**view层**进行代码分开，
分开的好处是不依赖视图，随时可以换掉view层，而不用修改状态管理的部分代码

- vuex 

这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux 和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。
## 3.vuex的基本用法
## 4.自己封装一个vuex